private void trimVideo(String inputPath, String outputPath, long startMs, long endMs) throws IOException {
    MediaExtractor extractor = new MediaExtractor();
    extractor.setDataSource(inputPath);

    int trackIndex = selectTrack(extractor);
    if (trackIndex < 0) {
        throw new IllegalArgumentException("No video track found in " + inputPath);
    }
    extractor.selectTrack(trackIndex);

    MediaFormat format = extractor.getTrackFormat(trackIndex);
    MediaCodec decoder = MediaCodec.createDecoderByType(format.getString(MediaFormat.KEY_MIME));
    decoder.configure(format, null, null, 0);
    decoder.start();

    MediaMuxer muxer = new MediaMuxer(outputPath, MediaMuxer.OutputFormat.MUXER_OUTPUT_MPEG_4);
    int videoTrackIndex = muxer.addTrack(format);
    muxer.start();

    // Set up for encoding
    MediaCodec encoder = MediaCodec.createEncoderByType(format.getString(MediaFormat.KEY_MIME));
    MediaFormat outputFormat = MediaFormat.createVideoFormat(format.getString(MediaFormat.KEY_MIME),
            format.getInteger(MediaFormat.KEY_WIDTH), format.getInteger(MediaFormat.KEY_HEIGHT));
    outputFormat.setInteger(MediaFormat.KEY_BIT_RATE, format.getInteger(MediaFormat.KEY_BIT_RATE));
    outputFormat.setInteger(MediaFormat.KEY_FRAME_RATE, format.getInteger(MediaFormat.KEY_FRAME_RATE));
    outputFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);
    outputFormat.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, 10);
    encoder.configure(outputFormat, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE);
    encoder.start();

    extractor.seekTo(startMs * 1000, MediaExtractor.SEEK_TO_CLOSEST_SYNC);
    long videoTimeUs = startMs * 1000;

    ByteBuffer[] decoderInputBuffers = decoder.getInputBuffers();
    ByteBuffer[] decoderOutputBuffers = decoder.getOutputBuffers();
    MediaCodec.BufferInfo info = new MediaCodec.BufferInfo();

    boolean isExtractorEOS = false;
    boolean isDecoderEOS = false;
    boolean isEncoderEOS = false;

    while (!isEncoderEOS) {
        // Extract frames and decode
        if (!isExtractorEOS) {
            int inputBufferIndex = decoder.dequeueInputBuffer(10000);
            if (inputBufferIndex >= 0) {
                ByteBuffer inputBuffer = decoderInputBuffers[inputBufferIndex];
                int sampleSize = extractor.readSampleData(inputBuffer, 0);
                if (sampleSize < 0) {
                    // End of stream
                    decoder.queueInputBuffer(inputBufferIndex, 0, 0, 0L, MediaCodec.BUFFER_FLAG_END_OF_STREAM);
                    isExtractorEOS = true;
                } else {
                    long presentationTimeUs = extractor.getSampleTime();
                    decoder.queueInputBuffer(inputBufferIndex, 0, sampleSize, presentationTimeUs, 0);
                    extractor.advance();
                }
            }
        }

        // Get decoded output
        int outputBufferIndex = decoder.dequeueOutputBuffer(info, 10000);
        if (outputBufferIndex >= 0) {
            ByteBuffer outputBuffer = decoderOutputBuffers[outputBufferIndex];
            if (info.presentationTimeUs >= startMs * 1000 && info.presentationTimeUs <= endMs * 1000) {
                // Process the frame (here you would encode the frame)
                encoder.queueInputBuffer(outputBufferIndex, 0, info.size, info.presentationTimeUs, 0);
            }
            decoder.releaseOutputBuffer(outputBufferIndex, false);

            if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
                isDecoderEOS = true;
            }
        }

        // Get encoded output
        int encoderOutputBufferIndex = encoder.dequeueOutputBuffer(info, 10000);
        if (encoderOutputBufferIndex >= 0) {
            ByteBuffer encodedData = encoder.getOutputBuffer(encoderOutputBufferIndex);
            if (encodedData != null) {
                muxer.writeSampleData(videoTrackIndex, encodedData, info);
                encoder.releaseOutputBuffer(encoderOutputBufferIndex, false);
            }

            if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
                isEncoderEOS = true;
            }
        }
    }

    decoder.stop();
    decoder.release();
    encoder.stop();
    encoder.release();
    extractor.release();
    muxer.stop();
    muxer.release();
}

private int selectTrack(MediaExtractor extractor) {
    int numTracks = extractor.getTrackCount();
    for (int i = 0; i < numTracks; i++) {
        MediaFormat format = extractor.getTrackFormat(i);
        String mime = format.getString(MediaFormat.KEY_MIME);
        if (mime.startsWith("video/")) {
            return i;
        }
    }
    return -1;
}
