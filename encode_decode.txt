public class VideoTranscoder {

    private static final int TIMEOUT_USEC = 10000; // Timeout for buffer operations

    private MediaCodec decoder;
    private MediaCodec encoder;
    private MediaExtractor extractor;

    public void transcodeVideo(String videoFilePath, Surface surface) throws IOException {
        extractor = new MediaExtractor();
        extractor.setDataSource(videoFilePath);

        int trackIndex = selectTrack(extractor);
        extractor.selectTrack(trackIndex);

        MediaFormat format = extractor.getTrackFormat(trackIndex);
        String mimeType = format.getString(MediaFormat.KEY_MIME);

        decoder = MediaCodec.createDecoderByType(mimeType);
        decoder.configure(format, surface, null, 0);

        MediaFormat outputFormat = MediaFormat.createVideoFormat("video/avc", format.getInteger(MediaFormat.KEY_WIDTH), format.getInteger(MediaFormat.KEY_HEIGHT));
        outputFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatYUV420Flexible);
        outputFormat.setInteger(MediaFormat.KEY_BIT_RATE, 1000000); // Example bitrate
        outputFormat.setInteger(MediaFormat.KEY_FRAME_RATE, 30); // Example frame rate
        outputFormat.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, 1); // Example I-frame interval

        encoder = MediaCodec.createEncoderByType("video/avc");
        encoder.configure(outputFormat, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE);

        decoder.setCallback(new MediaCodec.Callback() {
            @Override
            public void onInputBufferAvailable(MediaCodec codec, int index) {
                ByteBuffer inputBuffer = codec.getInputBuffer(index);
                int sampleSize = extractor.readSampleData(inputBuffer, 0);
                if (sampleSize < 0) {
                    codec.queueInputBuffer(index, 0, 0, 0, MediaCodec.BUFFER_FLAG_END_OF_STREAM);
                } else {
                    long presentationTimeUs = extractor.getSampleTime();
                    codec.queueInputBuffer(index, 0, sampleSize, presentationTimeUs, 0);
                    extractor.advance();
                }
            }

            @Override
            public void onOutputBufferAvailable(MediaCodec codec, int index, MediaCodec.BufferInfo info) {
                ByteBuffer outputBuffer = codec.getOutputBuffer(index);
                if (info.size > 0) {
                    outputBuffer.position(info.offset);
                    outputBuffer.limit(info.offset + info.size);
                    encode(outputBuffer, info);
                }
                codec.releaseOutputBuffer(index, false);
            }

            @Override
            public void onError(MediaCodec codec, MediaCodec.CodecException e) {
                e.printStackTrace();
            }

            @Override
            public void onOutputFormatChanged(MediaCodec codec, MediaFormat format) {
                // Handle format change if necessary
            }
        });

        encoder.setCallback(new MediaCodec.Callback() {
            @Override
            public void onInputBufferAvailable(MediaCodec codec, int index) {
                // Handle input buffer availability for encoding
            }

            @Override
            public void onOutputBufferAvailable(MediaCodec codec, int index, MediaCodec.BufferInfo info) {
                ByteBuffer outputBuffer = codec.getOutputBuffer(index);
                if (info.size > 0) {
                    outputBuffer.position(info.offset);
                    outputBuffer.limit(info.offset + info.size);
                    // Write encoded data to file or further processing
                }
                codec.releaseOutputBuffer(index, false);
            }

            @Override
            public void onError(MediaCodec codec, MediaCodec.CodecException e) {
                e.printStackTrace();
            }

            @Override
            public void onOutputFormatChanged(MediaCodec codec, MediaFormat format) {
                // Handle format change if necessary
            }
        });

        decoder.start();
        encoder.start();
    }

    private int selectTrack(MediaExtractor extractor) {
        for (int i = 0; i < extractor.getTrackCount(); i++) {
            MediaFormat format = extractor.getTrackFormat(i);
            String mime = format.getString(MediaFormat.KEY_MIME);
            if (mime.startsWith("video/")) {
                return i;
            }
        }
        throw new IllegalArgumentException("No video track found in " + extractor);
    }

    private void encode(ByteBuffer buffer, MediaCodec.BufferInfo info) {
        int inputBufferIndex = encoder.dequeueInputBuffer(TIMEOUT_USEC);
        if (inputBufferIndex >= 0) {
            ByteBuffer inputBuffer = encoder.getInputBuffer(inputBufferIndex);
            inputBuffer.clear();
            inputBuffer.put(buffer);
            encoder.queueInputBuffer(inputBufferIndex, 0, info.size, info.presentationTimeUs, info.flags);
        }
    }
}
