import android.media.MediaCodec;
import android.media.MediaExtractor;
import android.media.MediaFormat;
import android.media.MediaMuxer;
import android.util.Log;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.LinkedList;
import java.util.Queue;

public class VideoTranscoder {
    private static final String TAG = "VideoTranscoder";

    public static void transcodeVideo(String inputFilePath, String outputFilePath) throws IOException {
        MediaExtractor extractor = new MediaExtractor();
        extractor.setDataSource(inputFilePath);

        int videoTrackIndex = -1;
        MediaFormat format = null;
        for (int i = 0; i < extractor.getTrackCount(); i++) {
            format = extractor.getTrackFormat(i);
            String mime = format.getString(MediaFormat.KEY_MIME);
            if (mime.startsWith("video/")) {
                videoTrackIndex = i;
                break;
            }
        }

        if (videoTrackIndex == -1) {
            throw new RuntimeException("No video track found in file.");
        }

        extractor.selectTrack(videoTrackIndex);

        MediaCodec decoder = MediaCodec.createDecoderByType(format.getString(MediaFormat.KEY_MIME));
        MediaCodec encoder = MediaCodec.createEncoderByType("video/avc"); // Change to your desired mime type if needed

        MediaFormat outputFormat = MediaFormat.createVideoFormat(
                "video/avc", // Change to your desired mime type if needed
                format.getInteger(MediaFormat.KEY_WIDTH),
                format.getInteger(MediaFormat.KEY_HEIGHT));
        outputFormat.setInteger(MediaFormat.KEY_BIT_RATE, 2000000);
        outputFormat.setInteger(MediaFormat.KEY_FRAME_RATE, format.getInteger(MediaFormat.KEY_FRAME_RATE));
        outputFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatYUV420Flexible);
        outputFormat.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, 5);

        encoder.configure(outputFormat, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE);
        encoder.start();

        MediaMuxer muxer = new MediaMuxer(outputFilePath, MediaMuxer.OutputFormat.MUXER_OUTPUT_MPEG_4);
        int muxerTrackIndex = -1;
        boolean muxerStarted = false;

        Queue<MediaCodec.BufferInfo> bufferInfoQueue = new LinkedList<>();
        decoder.setCallback(new MediaCodec.Callback() {
            @Override
            public void onInputBufferAvailable(MediaCodec codec, int index) {
                ByteBuffer inputBuffer = codec.getInputBuffer(index);
                int sampleSize = extractor.readSampleData(inputBuffer, 0);
                if (sampleSize < 0) {
                    codec.queueInputBuffer(index, 0, 0, 0L, MediaCodec.BUFFER_FLAG_END_OF_STREAM);
                } else {
                    long presentationTimeUs = extractor.getSampleTime();
                    codec.queueInputBuffer(index, 0, sampleSize, presentationTimeUs, 0);
                    extractor.advance();
                }
            }

            @Override
            public void onOutputBufferAvailable(MediaCodec codec, int index, MediaCodec.BufferInfo info) {
                ByteBuffer outputBuffer = codec.getOutputBuffer(index);
                if (info.size > 0) {
                    outputBuffer.position(info.offset);
                    outputBuffer.limit(info.offset + info.size);

                    ByteBuffer encoderInputBuffer = encoder.getInputBuffer(encoder.dequeueInputBuffer(-1));
                    encoderInputBuffer.put(outputBuffer);
                    encoder.queueInputBuffer(index, info.offset, info.size, info.presentationTimeUs, info.flags);

                    if (info.flags == MediaCodec.BUFFER_FLAG_END_OF_STREAM) {
                        encoder.signalEndOfInputStream();
                    }
                }
                codec.releaseOutputBuffer(index, false);
            }

            @Override
            public void onError(MediaCodec codec, MediaCodec.CodecException e) {
                Log.e(TAG, "Decoder error: " + e.getMessage());
            }

            @Override
            public void onOutputFormatChanged(MediaCodec codec, MediaFormat format) {
                Log.d(TAG, "Decoder output format changed: " + format);
            }
        });

        encoder.setCallback(new MediaCodec.Callback() {
            @Override
            public void onInputBufferAvailable(MediaCodec codec, int index) {
                // No input buffer handling needed for encoder in this case
            }

            @Override
            public void onOutputBufferAvailable(MediaCodec codec, int index, MediaCodec.BufferInfo info) {
                ByteBuffer outputBuffer = codec.getOutputBuffer(index);
                if (muxerStarted) {
                    if (info.size > 0) {
                        outputBuffer.position(info.offset);
                        outputBuffer.limit(info.offset + info.size);
                        muxer.writeSampleData(muxerTrackIndex, outputBuffer, info);
                    }
                    codec.releaseOutputBuffer(index, false);
                }

                if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
                    muxer.stop();
                    muxer.release();
                    codec.stop();
                    codec.release();
                }
            }

            @Override
            public void onError(MediaCodec codec, MediaCodec.CodecException e) {
                Log.e(TAG, "Encoder error: " + e.getMessage());
            }

            @Override
            public void onOutputFormatChanged(MediaCodec codec, MediaFormat format) {
                if (muxerStarted) {
                    throw new RuntimeException("Format changed twice");
                }
                muxerTrackIndex = muxer.addTrack(format);
                muxer.start();
                muxerStarted = true;
            }
        });

        decoder.configure(format, null, null, 0);
        decoder.start();

        // Wait for the transcoding to complete
        while (true) {
            boolean finished = (extractor.getSampleTrackIndex() == -1);
            if (finished) break;
        }

        extractor.release();
    }
}
