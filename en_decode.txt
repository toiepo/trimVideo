import android.media.MediaCodec;
import android.media.MediaExtractor;
import android.media.MediaFormat;
import android.media.MediaMuxer;
import android.media.MediaCodec.BufferInfo;

import java.io.IOException;
import java.nio.ByteBuffer;

public class AdaptiveGOPVideoTrimmer {

    private static final int TIMEOUT_US = 10000;

    public static void trimVideo(String inputPath, String outputPath, long startMs, long endMs) throws IOException {
        MediaExtractor extractor = new MediaExtractor();
        extractor.setDataSource(inputPath);

        int trackCount = extractor.getTrackCount();
        MediaMuxer muxer = new MediaMuxer(outputPath, MediaMuxer.OutputFormat.MUXER_OUTPUT_MPEG_4);

        int videoTrackIndex = -1;
        int audioTrackIndex = -1;
        int muxerVideoTrackIndex = -1;
        int muxerAudioTrackIndex = -1;

        for (int i = 0; i < trackCount; i++) {
            MediaFormat format = extractor.getTrackFormat(i);
            String mime = format.getString(MediaFormat.KEY_MIME);
            if (mime.startsWith("video/")) {
                videoTrackIndex = i;
                muxerVideoTrackIndex = muxer.addTrack(format);
            } else if (mime.startsWith("audio/")) {
                audioTrackIndex = i;
                muxerAudioTrackIndex = muxer.addTrack(format);
            }
        }

        if (videoTrackIndex == -1) {
            throw new RuntimeException("No video track found in " + inputPath);
        }

        BufferInfo bufferInfo = new BufferInfo();
        muxer.start();

        // Extract and re-encode video frames
        extractor.selectTrack(videoTrackIndex);
        extractor.seekTo(startMs * 1000, MediaExtractor.SEEK_TO_PREVIOUS_SYNC);
        MediaCodec decoder = MediaCodec.createDecoderByType(extractor.getTrackFormat(videoTrackIndex).getString(MediaFormat.KEY_MIME));
        MediaCodec encoder = MediaCodec.createEncoderByType(extractor.getTrackFormat(videoTrackIndex).getString(MediaFormat.KEY_MIME));

        MediaFormat outputFormat = MediaFormat.createVideoFormat("video/avc", 1280, 720); // Adjust as necessary
        outputFormat.setInteger(MediaFormat.KEY_BIT_RATE, 2000000); // Adjust as necessary
        outputFormat.setInteger(MediaFormat.KEY_FRAME_RATE, 30); // Adjust as necessary
        outputFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatYUV420Flexible);
        outputFormat.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, 1); // Keyframe every second
        encoder.configure(outputFormat, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE);
        decoder.configure(extractor.getTrackFormat(videoTrackIndex), null, null, 0);

        decoder.start();
        encoder.start();

        ByteBuffer[] decoderInputBuffers = decoder.getInputBuffers();
        ByteBuffer[] decoderOutputBuffers = decoder.getOutputBuffers();
        ByteBuffer[] encoderInputBuffers = encoder.getInputBuffers();
        ByteBuffer[] encoderOutputBuffers = encoder.getOutputBuffers();

        boolean outputDone = false;
        boolean inputDone = false;
        boolean decoderDone = false;

        while (!outputDone) {
            if (!inputDone) {
                int inputBufferIndex = decoder.dequeueInputBuffer(TIMEOUT_US);
                if (inputBufferIndex >= 0) {
                    ByteBuffer inputBuffer = decoderInputBuffers[inputBufferIndex];
                    int chunkSize = extractor.readSampleData(inputBuffer, 0);
                    if (chunkSize < 0) {
                        decoder.queueInputBuffer(inputBufferIndex, 0, 0, 0, MediaCodec.BUFFER_FLAG_END_OF_STREAM);
                        inputDone = true;
                    } else {
                        long presentationTimeUs = extractor.getSampleTime();
                        if (presentationTimeUs < startMs * 1000) {
                            extractor.advance();
                        } else if (presentationTimeUs > endMs * 1000) {
                            inputDone = true;
                        } else {
                            decoder.queueInputBuffer(inputBufferIndex, 0, chunkSize, presentationTimeUs, extractor.getSampleFlags());
                            extractor.advance();
                        }
                    }
                }
            }

            boolean decoderOutputAvailable = !decoderDone;
            boolean encoderOutputAvailable = true;

            while (decoderOutputAvailable || encoderOutputAvailable) {
                int decoderOutputBufferIndex = decoder.dequeueOutputBuffer(bufferInfo, TIMEOUT_US);
                if (decoderOutputBufferIndex >= 0) {
                    if ((bufferInfo.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
                        decoderDone = true;
                        decoderOutputAvailable = false;
                    } else {
                        ByteBuffer decoderOutputBuffer = decoderOutputBuffers[decoderOutputBufferIndex];
                        decoderOutputBuffer.position(bufferInfo.offset);
                        decoderOutputBuffer.limit(bufferInfo.offset + bufferInfo.size);

                        int encoderInputBufferIndex = encoder.dequeueInputBuffer(TIMEOUT_US);
                        if (encoderInputBufferIndex >= 0) {
                            ByteBuffer encoderInputBuffer = encoderInputBuffers[encoderInputBufferIndex];
                            encoderInputBuffer.clear();
                            encoderInputBuffer.put(decoderOutputBuffer);

                            encoder.queueInputBuffer(encoderInputBufferIndex, 0, bufferInfo.size, bufferInfo.presentationTimeUs, bufferInfo.flags);
                            decoder.releaseOutputBuffer(decoderOutputBufferIndex, false);

                            if (bufferInfo.presentationTimeUs >= endMs * 1000) {
                                decoderDone = true;
                                decoderOutputAvailable = false;
                                encoder.queueInputBuffer(encoderInputBufferIndex, 0, 0, 0, MediaCodec.BUFFER_FLAG_END_OF_STREAM);
                            }
                        } else {
                            decoderOutputAvailable = false;
                        }
                    }
                } else if (decoderOutputBufferIndex == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {
                    decoderOutputBuffers = decoder.getOutputBuffers();
                } else if (decoderOutputBufferIndex == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {
                    // format changed
                } else {
                    decoderOutputAvailable = false;
                }

                int encoderOutputBufferIndex = encoder.dequeueOutputBuffer(bufferInfo, TIMEOUT_US);
                if (encoderOutputBufferIndex >= 0) {
                    ByteBuffer encodedData = encoderOutputBuffers[encoderOutputBufferIndex];
                    if (bufferInfo.size != 0) {
                        encodedData.position(bufferInfo.offset);
                        encodedData.limit(bufferInfo.offset + bufferInfo.size);
                        muxer.writeSampleData(muxerVideoTrackIndex, encodedData, bufferInfo);
                    }
                    encoder.releaseOutputBuffer(encoderOutputBufferIndex, false);

                    if ((bufferInfo.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
                        outputDone = true;
                        break;
                    }
                } else if (encoderOutputBufferIndex == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {
                    encoderOutputBuffers = encoder.getOutputBuffers();
                } else if (encoderOutputBufferIndex == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {
                    MediaFormat newFormat = encoder.getOutputFormat();
                    muxerVideoTrackIndex = muxer.addTrack(newFormat);
                    muxer.start();
                } else {
                    encoderOutputAvailable = false;
                }
            }
        }

        decoder.stop();
        decoder.release();
        encoder.stop();
        encoder.release();

        // Extract and write audio frames
        if (audioTrackIndex != -1) {
            extractor.unselectTrack(videoTrackIndex);
            extractor.selectTrack(audioTrackIndex);
            extractor.seekTo(startMs * 1000, MediaExtractor.SEEK_TO_CLOSEST_SYNC);

            while (true) {
                bufferInfo.offset = 0;
                bufferInfo.size = extractor.readSampleData(ByteBuffer.allocate(512 * 1024), 0);
                if (bufferInfo.size < 0) {
                    bufferInfo.size = 0;
                    break;
                }
                long audioTime = extractor.getSampleTime();
                if (audioTime > endMs * 1000) {
                    break;
                }
                bufferInfo.presentationTimeUs = audioTime;
                bufferInfo.flags = extractor.getSampleFlags();
                muxer.writeSampleData(muxerAudioTrackIndex, ByteBuffer.allocate(512 * 1024), bufferInfo);
                extractor.advance();
            }
        }

        muxer.stop();
        muxer.release();
        extractor.release();
    }
}
