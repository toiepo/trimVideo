// Example function to trim a video
private void trimVideo(String inputVideoPath, String outputVideoPath, long startMs, long endMs) throws IOException {
    MediaExtractor extractor = new MediaExtractor();
    extractor.setDataSource(inputVideoPath);

    MediaFormat format = extractor.getTrackFormat(0); // assuming video is the first track
    int videoTrackIndex = -1;
    for (int i = 0; i < extractor.getTrackCount(); i++) {
        format = extractor.getTrackFormat(i);
        String mime = format.getString(MediaFormat.KEY_MIME);
        if (mime.startsWith("video/")) {
            videoTrackIndex = i;
            break;
        }
    }

    extractor.selectTrack(videoTrackIndex);

    MediaCodec decoder = MediaCodec.createDecoderByType(format.getString(MediaFormat.KEY_MIME));
    decoder.configure(format, null, null, 0);
    decoder.start();

    MediaCodec.BufferInfo bufferInfo = new MediaCodec.BufferInfo();
    MediaMuxer muxer = new MediaMuxer(outputVideoPath, MediaMuxer.OutputFormat.MUXER_OUTPUT_MPEG_4);

    int trackIndex = muxer.addTrack(format);
    muxer.start();

    boolean sawInputEOS = false;
    boolean sawOutputEOS = false;
    long currentTimeUs = 0;

    decoder.flush();
    extractor.seekTo(startMs * 1000, MediaExtractor.SEEK_TO_PREVIOUS_SYNC);

    while (!sawOutputEOS) {
        if (!sawInputEOS) {
            int inputBufIndex = decoder.dequeueInputBuffer(10000);
            if (inputBufIndex >= 0) {
                ByteBuffer inputBuf = decoder.getInputBuffer(inputBufIndex);
                int sampleSize = extractor.readSampleData(inputBuf, 0);
                if (sampleSize < 0) {
                    sawInputEOS = true;
                    decoder.queueInputBuffer(inputBufIndex, 0, 0, 0, MediaCodec.BUFFER_FLAG_END_OF_STREAM);
                } else {
                    currentTimeUs = extractor.getSampleTime();
                    if (currentTimeUs >= endMs * 1000) {
                        sawInputEOS = true;
                        decoder.queueInputBuffer(inputBufIndex, 0, 0, 0, MediaCodec.BUFFER_FLAG_END_OF_STREAM);
                    } else {
                        decoder.queueInputBuffer(inputBufIndex, 0, sampleSize, currentTimeUs, 0);
                        extractor.advance();
                    }
                }
            }
        }

        int outputBufIndex = decoder.dequeueOutputBuffer(bufferInfo, 10000);
        if (outputBufIndex >= 0) {
            ByteBuffer outputBuf = decoder.getOutputBuffer(outputBufIndex);
            muxer.writeSampleData(trackIndex, outputBuf, bufferInfo);
            decoder.releaseOutputBuffer(outputBufIndex, false);
            if ((bufferInfo.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
                sawOutputEOS = true;
            }
        }
    }

    muxer.stop();
    muxer.release();
    decoder.stop();
    decoder.release();
    extractor.release();
}
